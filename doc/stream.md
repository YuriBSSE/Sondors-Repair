# Stream notes

- create channels with an explicit ID -- otherwise, Stream will ensure only one chat exists between the members you specify, automatically re-using an existing chat down the line if/when you create a chat with the same customer/provider pair. This is probably not what we want. By specifying a random ID (I used `openssl rand -hex 12` at the CLI for the demo channels), you are instructing Stream to not auto-consolidate all chats/channels with the same initial member list into the same channel.
- when creating a channel, you just need to provide the creator/owner of the channel (by Stream user ID) and any members of the channel (and as aforementioned, a unique ID for the channel). It may make sense to have a third "moderator" user that creates all the channels so that there is a neutral party who "owns" the channel, rather than the Provider or the Customer. However, anyone specified as an initial member for the channel appears to automatically be an "admin" (versus "owner" for whoever is specified as the creator). Whether this is always the default or the default because we are using the Messaging "channel type" is unclear.
- when running one of Stream's `query*` functions e.g. `queryChannels`, you probably want to pass `{ watch: false }` as the 3rd parameter; in most cases we are calling these, we probably don't need to watch. Most of the cases where "watching" for future changes needs to happen should be handled by Stream's React Native components.
- Stream's React Native components take complete "Channel" objects as props, not e.g. a channel Id... so even though we are storing the channel ID in Hasura (presumably), at least "queryChannels" will need to be called from our front-end code before handing off to the Stream React Native components.
- Either a trigger/hook on Hasura (via "upsertUser" or similar) or as necessary on React Native (via "connectUser" or similar) can update the user's name and profile picture.
- Doesn't seem like much data from Stream will be needed in Hasura's data stores, other than storing off channel IDs and user IDs as they are created.
- What is the workflow for when a user is created? A couple mutually exclusive ideas:
    - whenever a user authenticates with Hasura/Auth0/whatever-that-looks-like, user is created from that back-end code, which also updates the User table with the stream/external ID. Then every so often (either as a result of a specific call or database change, or simply in-bulk on a regular basis if lazy) the server side calls `upsertUsers` to update name & profile picture.
    - connectUser will create a user if it doesn't exist with the default "user" role... if we work around that knowledge (they can create channels it seems), it could be possible so the front-end handles most/all of this for a while.
- What is the workflow for creating a channel in the final solution?
    * if a "moderator"/neutral user is the owner/creator of channels, the back-end will have to do it.
    * otherwise, the front-end can do it
- Eventually, some server side code will need to call createToken for the front-end to authenticate with Stream, for security reasons -- the Stream **secret** key has to be used for this can can't be shipped with the front-end or it'd be compromised. In the demo, a temporary `devToken` method is used instead, so only the Stream **api** key (okay for public consumption, and staying in the front-end) is used.
